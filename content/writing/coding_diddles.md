+++
title = "Coding Diddles"
author = ["Walker Griggs"]
date = 2022-08-07
draft = true
creator = "Emacs 28.1 (Org mode 9.5.2 + ox-hugo)"
weight = 2006
+++

Last year, a colleague of mine picked up woodcarving. They told me about their battle with the “originality demon” and how, even when learning a new and productively right-brain skill, they felt every knife stroke needed to be an original one. Each complete whittle needed to an attractive addition to a catalog of novel works.

Then a content creator – a carving guru, as my colleague referred to him – referred to some of their more simple or instructive carvings as a “diddle”. These diddles were common, practiced, and rehearsed; there’s absolutely nothing original about these them. Yet, they were a critical part of this creator's trade, and so my colleague took solace in the idea that regardless of profession or experience, we need to iterate on the trite before we can produce even a modicum of original work.

My colleagues' story resonated with me; programming is no different! I can’t count the number of times I…

1.  stumble on a new idea
2.  excitedly put pen to paper
3.  resurface a few hours later to learn, after some light ‘market research’, that someone else has solved the problem.

At that point I’m faced with the decision to write it off as a fun investigation or to forge ahead knowing that someone beat me to the punch. And of course someone else has! Given the glut of public repos on Github alone, it’s hard to imagine some problems haven’t been solved.

I wouldn’t call this a particularly productive outlook, but for some innate reason it’s a shared human experience.

When you frame your projects are diddles though, your perspective shifts (for the better). Sorting algorithms, data structures, security groups, EMNIST dataset, hello worlds – all are diddles. There’s nothing original about heap sort and certainly classifying handwritten letters is a solved problem. We should take solace in that. Before we write our magnum opal, we should understand existing systems. How can we presume to be entirely original until we know all prior art.

There’s another part to diddles too. In a recent post about Basic English and controlled languages, I touched on that, to learn quickly we need to first learn slowly. By limiting the syllabus to the most common parts, we’re giving ourselves time to build a solid, reliable, and practical foundation. My colleague carved 15+ canoes in one weekend, but their last iteration was infinitely better than their first.

By freeing themselves from the need to produce original work, they were able to focus on the techniques of carving. Thinking about my own experience learning Go, I probably wrote just as many CLIs as they carved canoes. CLIs aren’t sexy and they’re most certainly not novel. But now I can whip out a CLI faster than you read this post. And how many times have I needed to in the wild. Tons!

So write like Didion! Paint like Jackson! Dribble like Jordan!

Practice your diddles, re-implement your darlings, and study how “innovations” make use of your favorite data structures. Before you blow anyone’s mind, first learn what makes their brain tick.